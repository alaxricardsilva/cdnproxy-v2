import { logger } from '~/utils/logger'
import { defineEventHandler, createError, readBody } from 'h3'
import { requireAdminAuth } from '../../../../utils/hybrid-auth'
import { generatePixQRCode, validatePixKey } from '../../../../utils/pix-generator'

export default defineEventHandler(async (event) => {
  try {
    logger.info('üîÑ [PIX PAYMENT API] Iniciando...')
    
    // Authenticate admin and get Supabase client
    const { user, supabase } = await requireAdminAuth(event)
    logger.info('‚úÖ [PIX PAYMENT API] Autentica√ß√£o OK:', user.id)

    // Get request body
    const body = await readBody(event)
    logger.info('üìã [PIX PAYMENT API] Dados recebidos:', body)

    // Validate required fields
    if (!body.domains || !Array.isArray(body.domains) || body.domains.length === 0) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Lista de dom√≠nios √© obrigat√≥ria'
      })
    }

    if (!body.plan_id || !body.amount) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Plano e valor s√£o obrigat√≥rios'
      })
    }

    // Verify domains belong to user
    let domainsQuery = supabase
      .from('domains')
      .select('id, domain')
      .in('id', body.domains)

    // Only filter by user_id if user.id is a valid UUID (not 'admin')
    if (user.id !== 'admin' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(user.id)) {
      domainsQuery = domainsQuery.eq('user_id', user.id)
    }

    const { data: userDomains, error: domainsError } = await domainsQuery

    if (domainsError || !userDomains || userDomains.length !== body.domains.length) {
      logger.error('‚ùå [PIX PAYMENT API] Erro ao verificar dom√≠nios:', domainsError)
      throw createError({
        statusCode: 404,
        statusMessage: 'Um ou mais dom√≠nios n√£o encontrados ou n√£o pertencem ao usu√°rio'
      })
    }

    // Get plan details
    const { data: plan, error: planError } = await supabase
      .from('plans')
      .select('*')
      .eq('id', body.plan_id)
      .single()

    if (planError || !plan) {
      logger.error('‚ùå [PIX PAYMENT API] Plano n√£o encontrado:', planError)
      throw createError({
        statusCode: 404,
        statusMessage: 'Plano n√£o encontrado'
      })
    }

    // Get PIX key and validate
    const pixKey = process.env.PIX_KEY || 'admin@cdnproxy.top'
    const pixAmount = parseFloat(body.amount)
    const pixDescription = `Renova√ß√£o de ${userDomains.length} dom√≠nio(s) - ${userDomains.map(d => d.domain).join(', ')}`
    
    // Validate PIX key
    const keyValidation = validatePixKey(pixKey)
    if (!keyValidation.valid) {
      throw createError({
        statusCode: 500,
        statusMessage: `Chave PIX inv√°lida configurada: ${pixKey}. Configure uma chave PIX v√°lida em PIX_KEY.`
      })
    }
    
    logger.info('‚úÖ [PIX PAYMENT API] Chave PIX validada:', { pixKey, type: keyValidation.type })
    
    // Generate transaction ID (UUID will be auto-generated by database)
    const transactionId = `pix_${Date.now()}_${user.id}`

    // Create transaction record
    const transactionData = {
      user_id: user.id === 'admin' ? 'ab9f7874-c0d9-42f5-b4da-45b6e0793138' : user.id, // Use superadmin UUID for 'admin'
      amount: pixAmount,
      currency: 'BRL',
      type: 'renewal',
      status: 'pending',
      payment_method: 'pix',
      description: pixDescription,
      metadata: {
        plan_id: body.plan_id,
        plan_name: plan.name,
        domains: userDomains,
        pix_key: pixKey,
        pix_amount: pixAmount,
        pix_description: pixDescription,
        duration_value: plan.duration_value,
        duration_type: plan.duration_type
      }
    }

    const { data: transaction, error: transactionError } = await supabase
      .from('transactions')
      .insert(transactionData)
      .select()
      .single()

    if (transactionError) {
      logger.error('‚ùå [PIX PAYMENT API] Erro ao criar transa√ß√£o:', JSON.stringify(transactionError, null, 2))
      logger.error('‚ùå [PIX PAYMENT API] Dados da transa√ß√£o:', JSON.stringify(transactionData, null, 2))
      throw createError({
        statusCode: 500,
        statusMessage: 'Erro ao criar transa√ß√£o',
        data: { error: transactionError, transactionData }
      })
    }

    logger.info('‚úÖ [PIX PAYMENT API] Transa√ß√£o PIX criada:', transaction.id)

    // Generate PIX QR Code with proper EMV format
    const pixQRCode = await generatePixQRCode({
      pixKey,
      amount: pixAmount,
      description: pixDescription,
      transactionId: transaction.id,
      merchantName: 'Suporte',
      merchantCity: 'SAO PAULO'
    })

    logger.info('‚úÖ [PIX PAYMENT API] QR Code PIX gerado:', {
      emvLength: pixQRCode.emvCode.length,
      pixKeyType: pixQRCode.pixKeyType,
      hasImage: !!pixQRCode.qrCodeImage
    })

    // Update transaction with PIX code in metadata
    const { error: updateError } = await supabase
      .from('transactions')
      .update({
        metadata: {
          ...transactionData.metadata,
          pix_code: pixQRCode.emvCode,
          qr_code: pixQRCode.emvCode,
          qr_code_image: pixQRCode.qrCodeImage,
          qr_code_base64: pixQRCode.qrCodeBase64,
          pix_key_type: pixQRCode.pixKeyType
        }
      })
      .eq('id', transaction.id)

    if (updateError) {
      logger.error('‚ùå [PIX PAYMENT API] Erro ao atualizar metadata:', updateError)
      // N√£o falhar a opera√ß√£o por causa do metadata
    }

    logger.info('‚úÖ [PIX PAYMENT API] QR Code PIX salvo no metadata')

    return {
      success: true,
      data: {
        transaction_id: transaction.id,
        pix_key: pixKey,
        pix_key_type: pixQRCode.pixKeyType,
        amount: pixAmount,
        description: pixDescription,
        pix_code: pixQRCode.emvCode,
        qr_code: pixQRCode.emvCode,
        qr_code_image: pixQRCode.qrCodeImage,
        qr_code_base64: pixQRCode.qrCodeBase64,
        domains: userDomains,
        expires_at: new Date(Date.now() + 30 * 60 * 1000).toISOString() // 30 minutes
      }
    }

  } catch (error: any) {
    logger.error('Erro na API admin/payments/pix:', error)
    
    // Se j√° √© um erro HTTP, re-lan√ßar
    if (error.statusCode) {
      throw error
    }
    
    // Erro gen√©rico
    throw createError({
      statusCode: 500,
      statusMessage: error.message || 'Erro interno do servidor'
    })
  }
})